use world::world_sim::WorldSim;
use types::std_string::StdString;

backend rust prologue "use crate::{SharedPtr, Vehicle};";

#[size(8), align(4)]
extern type SharedPtr<Vehicle>;

#[size(0x58)]
pub type LoadedModel {
    pub load_state: i32,
    
    #[address(0xC)]
    pub model_id: u32,

    #[address(0x2C)]
    pub flags_pl_mik_mi_omik_omi_he_ws: i32,
}

#[size(0x34)]
pub type VehicleTypes {
    hash_edacd65b_likely_max_models: i32,
    hash_2ff58884: i32,
    pub maximum_gpu_cost: i32,
    pub maximum_cpu_cost: i32,
    
    #[address(0x14)]
    pub accumulated_gpu_cost: i32,
    pub accumulated_cpu_cost: i32,
    
    #[address(0x20)]
    pub loaded_models: *const LoadedModel,
}

#[size(0x1754), singleton(0x1_191_918)]
pub type SpawnManager {
    #[address(0x78)]
    pub max_num_characters: u16,
    pub max_num_vehicles: u16,

    #[address(0xA00)]
    pub world_sim: WorldSim,
    pub enemy_type_spawn_settings: unknown<804>,
    pub character_types: unknown<0x74>,
    pub vehicle_types: VehicleTypes,
}
impl SpawnManager {
    #[address(0x84C_4C0)]
    pub fn engine_spawn_vehicle(
        &mut self,
        vehicle: *mut SharedPtr<Vehicle>,
        context: i32,
        unk1: *mut StdString,
        model_id: *const u32,
        faction: u32,
        unk2: *mut StdString
    ) -> *mut SharedPtr<Vehicle>;

    #[address(0x73F_DB0)]
    pub fn request_vehicle_model(&mut self, model_id: *const u32, category: i32);
}
backend rust epilogue r#"
    impl SpawnManager {
        pub unsafe fn is_vehicle_loaded(&self, id: u32) -> bool {
            (0..self.vehicle_types.hash_edacd65b_likely_max_models).any(|i| unsafe {
                let model = self.vehicle_types.loaded_models.offset(i as isize);
                let model_id = (&raw const (*model).model_id).read();
                let load_state = (&raw const (*model).load_state).read();
                model_id == id && load_state == 2
            })
        }
    }
"#;